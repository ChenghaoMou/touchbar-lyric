[
  {
    "BTTWidgetName": "Lyric",
    "BTTTriggerType": 642,
    "BTTTriggerTypeDescription": "Shell Script / Task Widget",
    "BTTTriggerClass": "BTTTriggerTypeTouchBar",
    "BTTPredefinedActionType": -1,
    "BTTPredefinedActionName": "No Action",
    "BTTShellScriptWidgetGestureConfig": "/Users/chenghaomou/Anaconda/bin/python:::-c:::-:::",
    "BTTEnabled2": 1,
    "BTTUUID": "",
    "BTTNotesInsteadOfDescription": 0,
    "BTTEnabled": 1,
    "BTTModifierMode": 0,
    "BTTOrder": 1,
    "BTTDisplayOrder": 0,
    "BTTMergeIntoTouchBarGroups": 0,
    "BTTTriggerConfig": {
      "BTTTouchBarButtonCornerRadius": 6,
      "BTTTouchBarButtonColor": "0.000000, 0.000000, 0.000000, 255.000000",
      "BTTTouchBarApplyCornerRadiusTo": 0,
      "BTTTouchBarItemPlacement": 0,
      "BTTTouchBarAppleScriptStringRunOnInit": true,
      "BTTTouchBarFontColorAlternate": "0.000000, 0.000000, 0.000000, 255.000000",
      "BTTTouchBarAlwaysShowButton": false,
      "BTTScriptType": 0,
      "BTTTouchBarScriptUpdateInterval": 1,
      "BTTTouchBarButtonWidth": 550,
      "BTTTouchBarItemIconHeight": 22,
      "BTTTouchBarButtonTextAlignment": 1,
      "BTTTouchBarButtonUseFixedWidth": 0,
      "BTTTouchBarAlternateBackgroundColor": "0.000000, 0.000000, 0.000000, 255.000000",
      "BTTTBWidgetWidth": 400,
      "BTTTouchBarItemIconWidth": 22,
      "BTTTouchBarShellScriptString": "import os\nimport re\nimport binascii\nimport base64\nimport json\nimport copy\nimport requests\nfrom Crypto.Cipher import AES\nimport requests\nimport osascript\nimport hashlib\nimport time\nimport math\nimport requests\nfrom cachier import cachier\nimport datetime\nfrom dataclasses import dataclass\nfrom typing import *\nimport pinyin\nfrom hanziconv import HanziConv\n\n\nclass NeteaseRequest:\n\n    session = requests.Session()\n    session.headers.update({\n        \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\",\n        \"Accept-Charset\": \"UTF-8,*;q=0.5\",\n        \"Accept-Encoding\": \"gzip,deflate,sdch\",\n        \"Accept-Language\": \"en-US,en;q=0.8\",\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; WOW64; rv:60.0) Gecko/20100101 Firefox/60.0\",\n        \"referer\": \"http://music.163.com/\",\n    })\n\n    @classmethod\n    def encode_netease_data(cls, data) -> str:\n        data = json.dumps(data)\n        key = binascii.unhexlify(\"7246674226682325323F5E6544673A51\")\n        encryptor = AES.new(key, AES.MODE_ECB)\n        pad = 16 - len(data) % 16\n        fix = chr(pad) * pad\n        byte_data = (data + fix).encode(\"utf-8\")\n        return binascii.hexlify(encryptor.encrypt(byte_data)).upper().decode()\n\n    @classmethod\n    def encrypted_request(cls, data) -> dict:\n        MODULUS = (\n            \"00e0b509f6259df8642dbc35662901477df22677ec152b5ff68ace615bb7\"\n            \"b725152b3ab17a876aea8a5aa76d2e417629ec4ee341f56135fccf695280\"\n            \"104e0312ecbda92557c93870114af6c9d05c4f7f0c3685b7a46bee255932\"\n            \"575cce10b424d813cfe4875d3e82047b97ddef52741d546b8e289dc6935b\"\n            \"3ece0462db0a22b8e7\"\n        )\n        PUBKEY = \"010001\"\n        NONCE = b\"0CoJUm6Qyw8W8jud\"\n        data = json.dumps(data).encode(\"utf-8\")\n        secret = cls.create_key(16)\n        params = cls.aes(cls.aes(data, NONCE), secret)\n        encseckey = cls.rsa(secret, PUBKEY, MODULUS)\n        return {\"params\": params, \"encSecKey\": encseckey}\n\n    @classmethod\n    def aes(cls, text, key):\n        pad = 16 - len(text) % 16\n        text = text + bytearray([pad] * pad)\n        encryptor = AES.new(key, 2, b\"0102030405060708\")\n        ciphertext = encryptor.encrypt(text)\n        return base64.b64encode(ciphertext)\n\n    @classmethod\n    def rsa(cls, text, pubkey, modulus):\n        text = text[::-1]\n        rs = pow(int(binascii.hexlify(text), 16), int(pubkey, 16), int(modulus, 16))\n        return format(rs, \"x\").zfill(256)\n\n    @classmethod\n    def create_key(cls, size):\n        return binascii.hexlify(os.urandom(size))[:16]\n\n    @classmethod\n    def request(cls, url, method=\"POST\", data=None):\n        if method == \"GET\":\n            resp = cls.session.get(url, params=data, timeout=7)\n        else:\n            resp = cls.session.post(url, data=data, timeout=7)\n        if resp.status_code != requests.codes.ok:\n            raise RequestError(resp.text)\n        if not resp.text:\n            raise ResponseError(\"No response data.\")\n        return resp.json()\n\n\n@dataclass\nclass NeteaseSong:\n\n    id: str\n    title: str\n    artists: str\n\n\n@cachier(stale_after=datetime.timedelta(days=1))\ndef get_lyric(id) -> str:\n    row_data = {\"csrf_token\": \"\", \"id\": id, \"lv\": -1, \"tv\": -1}\n    data = NeteaseRequest.encrypted_request(row_data)\n\n    return NeteaseRequest.request(\n        \"https://music.163.com/weapi/song/lyric\", method=\"POST\", data=data\n    ).get(\"lrc\", {}).get(\"lyric\", \"\")\n\n\n@cachier(stale_after=datetime.timedelta(days=3))\ndef search(title, artists) -> List[NeteaseSong]:\n\n    eparams = {\n        \"method\": \"POST\",\n        \"url\": \"http://music.163.com/api/cloudsearch/pc\",\n        \"params\": {\"s\": title, \"type\": 1, \"offset\": 0, \"limit\": 30},\n    }\n    data = {\"eparams\": NeteaseRequest.encode_netease_data(eparams)}\n\n    songs_list = []\n    res_data = (\n        NeteaseRequest.request(\n            \"http://music.163.com/api/linux/forward\", method=\"POST\", data=data\n        )\n        .get(\"result\", {})\n        .get(\"songs\", {})\n    )\n    artists = artists.replace(' ', '').replace(',', '').replace('-', '').lower()\n    artists = pinyin.get(artists, delimiter='', format='strip')\n    backup = []\n\n    for item in res_data:\n\n        singers = [pinyin.get(s.get(\"name\", \"\").replace(' ', ''), delimiter='', format='strip').lower() for s in item.get(\"ar\", [])]\n        found = False\n        # print(singers, artists)\n        for singer in singers:\n            if singer in artists:\n                found = True\n\n        song = NeteaseSong(\n            id=item.get(\"id\", \"\"),\n            title=item.get(\"name\", \"\"),\n            artists=\"\".join(singers),\n        )\n        if found:\n            songs_list.append(song)\n        else:\n            backup.append(song)\n    # print(songs_list, backup)\n    return songs_list if songs_list else backup[:1]\n\n\ndef get_lyrics(songs: List[NeteaseSong]) -> List:\n    for song in songs:\n        lyric = get_lyric(song.id)\n        if lyric is not None:\n            return lyric\n\n\ndef get_info():\n    code, res, error = osascript.run('''\n            on run\n                if application \"Spotify\" is running then\n                    tell application \"Spotify\"\n                        set currentInfo to {\"Spotify\", artist of current track, \"###\", name of current track, player position, player state, duration of current track}\n                    end tell\n                else if application \"Music\" is running then\n                    tell application \"Music\"\n                        set currentInfo to {\"Music\", artist of current track, \"###\", name of current track, player position, player state, duration of current track}\n                    end tell\n                end if\n                return currentInfo\n            end run\n    ''', background=False)\n\n    if res:\n        info = res.split('###')\n\n        application, *artists = map(lambda x: x.strip(), info[0].strip(' ,').split(','))\n        artists = ','.join(artists)\n\n        *title, position, status, duration = map(lambda x: x.strip(), info[1].strip(' ,').split(','))\n        title = ','.join(title)\n\n        if float(duration) <= 1200:\n            duration = float(duration)\n            position = float(position)\n        else:\n            duration = float(duration) / 3600\n            position = float(position)\n\n        title = HanziConv.toSimplified(title)\n\n        return application, artists, title, position, status, duration\n    else:\n        return None\n\n\ndef parse(lyric, position, duration):\n    if lyric is None:\n        return\n    # print(position)\n    lines = [line for line in lyric.split('\\n') if line.strip()]\n\n    def parse_line(line):\n\n        if not re.findall('\\[([0-9]+):([0-9])+\\.([0-9]+)\\]', line):\n            return 0, line\n        # print(re.findall('\\[([0-9]+):([0-9])+\\.([0-9]+)\\]', line))\n        minute, second, _ = re.findall('\\[([0-9]+):([0-9]+)\\.([0-9]+)\\]', line)[0]\n        curr = int(minute) * 60 + int(second)\n        words = re.sub('\\[.*?\\]', '', line)\n        # print(minute, second)\n        return curr, words\n\n    lines = list(map(parse_line, lines))\n\n    if all(line[0] == 0 for line in lines):\n        _, words = lines[min(int(len(lines) * position / duration), len(lines)-1)]\n        return '❌ ' + words\n\n    starts = [0] + [line[0] for line in lines][:-1]\n    ends = [line[0] for line in lines]\n    lines = [line[-1] for line in lines]\n\n    for start, end, words in zip(starts, ends, [\"\"] + lines):\n        if start <= position <= end:\n            return words\n\n\ndef main():\n    res = get_info()\n\n    if res is None:\n        print('404 No lyric found')\n        return\n    else:\n        application, artists, title, position, status, duration = res\n\n    if status != 'playing':\n        return\n    else:\n\n        songs = search(title, artists)\n        lyric = get_lyrics(songs)\n        words = parse(lyric, position, duration)\n        if words is not None:\n            print(words)\n        elif words == '':\n            print('~')\n        elif words is None:\n            print(f'{application.title()} -- {title} -- {artists}')\n        return\n\n\nif __name__ == \"__main__\":\n    # search.clear_cache()\n    main()\n",
      "BTTTouchBarButtonFontSize": 12,
      "BTTTouchBarFontColor": "156.000006, 226.000002, 90.000002, 255.000000",
      "BTTTouchBarButtonName": "Lyric",
      "BTTTouchBarOnlyShowIcon": false,
      "BTTTouchBarFreeSpaceAfterButton": 0,
      "BTTTouchBarItemPadding": 20
    }
  }
]
